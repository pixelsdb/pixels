/*
 * Copyright 2024 PixelsDB.
 *
 * This file is part of Pixels.
 *
 * Pixels is free software: you can redistribute it and/or modify
 * it under the terms of the Affero GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * Pixels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Affero GNU General Public License for more details.
 *
 * You should have received a copy of the Affero GNU General Public
 * License along with Pixels.  If not, see
 * <https://www.gnu.org/licenses/>.
 */

/*
 * @author gengdy
 * @create 2024-11-09
 */
#include <utils/ConfigFactory.h>
#include "utils/BitUtils.h"
#include "writer/ColumnWriter.h"

const int ColumnWriter::ISNULL_ALIGNMENT = std::stoi(ConfigFactory::Instance().getProperty("isnull.bitmap.alignment"));
const std::vector <uint8_t> ColumnWriter::ISNULL_PADDING_BUFFER(ColumnWriter::ISNULL_ALIGNMENT, 0);

std::vector <uint8_t> ColumnWriter::getColumnChunkContent() const
{
    auto begin = outputStream->getPointer() + outputStream->getReadPos();
    auto end = outputStream->getPointer() + outputStream->getWritePos();
    return std::vector<uint8_t>(begin, end);
}

int ColumnWriter::getColumnChunkSize() const
{
    return static_cast<int>(outputStream->getWritePos() - outputStream->getReadPos());
}

const flatbuffers::Offset<pixels::fb::ColumnChunkIndex> ColumnWriter::getColumnChunkIndex()
{
    return columnChunkIndex;
}

flatbuffers::Offset<pixels::fb::ColumnChunkIndex> ColumnWriter::buildColumnChunkIndex(flatbuffers::FlatBufferBuilder& fbb, uint64_t chunkOffset, uint32_t chunkLength, bool littleEndian)
{
    // Build pixel positions vector
    auto positions = fbb.CreateVector(pixelPositions);

    // Rebuild pixel statistics from saved snapshots
    std::vector<flatbuffers::Offset<pixels::fb::PixelStatistic>> pixelStats;
    pixelStats.reserve(pixelStatSnapshots.size());

    /**
     *  Traverse statistical snapshots to serialize C++ objects in memory
     *  to flattbuffers format
     */
    
    for (auto& snapshot : pixelStatSnapshots) {
        // snapShot.colStatObj.get() get original pointers of  C++ objects(generated by Object API)
        // The Pack method will recursively write all fields of the object into the fbb buffer.
        auto colStatOffset = pixels::fb::ColumnStatistic::Pack(fbb, snapshot.colStatObj.get());

        auto pixelStatOffset = pixels::fb::CreatePixelStatistic(fbb, colStatOffset);
        pixelStats.push_back(pixelStatOffset);
    }
    
    auto statistics = fbb.CreateVector(pixelStats);

    // Build ColumnStatistic for the chunk
    auto chunkStat = columnChunkStatRecorder.serialize(fbb);

    // Create ColumnChunkIndex
    auto index = pixels::fb::CreateColumnChunkIndex(
        fbb,
        chunkOffset,  // chunkOffset
        chunkLength,  // chunkLength
        isNullOffset,
        positions,
        statistics,
        littleEndian,  // littleEndian
        nullsPadding,
        ISNULL_ALIGNMENT
    );
    return index;
}


const flatbuffers::Offset<pixels::fb::ColumnEncoding> ColumnWriter::getColumnChunkEncoding(flatbuffers::FlatBufferBuilder &fbb) const
{
    // Build a simple ColumnEncoding with NONE kind
    auto encoding = pixels::fb::CreateColumnEncoding(
        fbb,
        pixels::fb::EncodingKind_NONE,
        0,  // dictionarySize
        0   // cascadeEncoding
    );
    return encoding;
}


void ColumnWriter::flush()
{
    if (curPixelEleIndex > 0)
    {
        newPixel();
    }
    
    isNullOffset = static_cast<int>(outputStream->getWritePos());
    if (ISNULL_ALIGNMENT != 0 && isNullOffset % ISNULL_ALIGNMENT != 0)
    {
        int alignBytes = ISNULL_ALIGNMENT - (isNullOffset % ISNULL_ALIGNMENT);
        outputStream->putBytes(const_cast<uint8_t *>(ISNULL_PADDING_BUFFER.data()), alignBytes);
        isNullOffset += alignBytes;
    }
    
    outputStream->putBytes(isNullStream->getPointer() + isNullStream->getReadPos(),
                           isNullStream->getWritePos() - isNullStream->getReadPos());
    
    // Issue: align the entire column chunk to CHUNK_ALIGNMENT 
    // to ensure getColumnChunkSize() returns the correct aligned size
    static const int CHUNK_ALIGNMENT = std::stoi(ConfigFactory::Instance().getProperty("column.chunk.alignment"));
    static const std::vector<uint8_t> CHUNK_PADDING_BUFFER(CHUNK_ALIGNMENT, 0);
    
    int chunkSize = static_cast<int>(outputStream->getWritePos());
    if (CHUNK_ALIGNMENT != 0 && chunkSize % CHUNK_ALIGNMENT != 0)
    {
        int alignBytes = CHUNK_ALIGNMENT - (chunkSize % CHUNK_ALIGNMENT);
        outputStream->putBytes(const_cast<uint8_t *>(CHUNK_PADDING_BUFFER.data()), alignBytes);
    }
}

void ColumnWriter::newPixel()
{
    if (hasNull)
    {
        auto compacted = BitUtils::bitWiseCompact(isNull, curPixelIsNullIndex, byteOrder);
        isNullStream->putBytes(const_cast<uint8_t *>(compacted.data()), compacted.size());
        pixelStatRecorder.setHasNull();
    }
    
    curPixelPosition = static_cast<int>(outputStream->getWritePos());
    curPixelEleIndex = 0;
    curPixelVectorIndex = 0;
    curPixelIsNullIndex = 0;

    columnChunkStatRecorder.merge(pixelStatRecorder);

    // Add pixel position
    pixelPositions.push_back(lastPixelPosition);


    // Object API needed
    auto colStatT = std::make_unique<pixels::fb::ColumnStatisticT>();


    // save the object in memory,No need to loop in flatbuffers for this.
    PixelStatSnapshot snapshot;
    snapshot.colStatObj = std::move(colStatT);
    pixelStatSnapshots.push_back(std::move(snapshot));

    lastPixelPosition = curPixelPosition;
    pixelStatRecorder.reset();
    hasNull = false;
}

void ColumnWriter::reset()
{
    lastPixelPosition = 0;
    curPixelPosition = 0;
    
    // Clear flatbuffers data
    pixelPositions.clear();
    pixelStatSnapshots.clear();  // Clear snapshots instead of pixelStatistics
    columnChunkIndex = 0;
    columnChunkStat = nullptr;
    
    pixelStatRecorder.reset();
    columnChunkStatRecorder.reset();
    outputStream->resetPosition();
    isNullStream->resetPosition();
}

void ColumnWriter::close()
{
    outputStream->clear();
    isNullStream->clear();
}

ColumnWriter::ColumnWriter(std::shared_ptr <TypeDescription> type,
                           std::shared_ptr <PixelsWriterOption> writerOption)
        : pixelStride(writerOption->getPixelsStride()),
          encodingLevel(writerOption->getEncodingLevel()),
          byteOrder(writerOption->getByteOrder()),
          nullsPadding(writerOption->isNullsPadding()),// default is false
          isNull(pixelStride, false),
          columnChunkIndex(0),
          columnChunkStat(nullptr)
{
    outputStream = std::make_shared<ByteBuffer>(pixelStride);
    isNullStream = std::make_shared<ByteBuffer>(pixelStride);
    
    // Reserve space for pixel positions and statistics snapshots
    pixelPositions.reserve(100);  // reasonable initial capacity
    pixelStatSnapshots.reserve(100);
}
