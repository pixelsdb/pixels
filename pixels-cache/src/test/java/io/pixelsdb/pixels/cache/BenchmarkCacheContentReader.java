/*
 * Copyright 2022 PixelsDB.
 *
 * This file is part of Pixels.
 *
 * Pixels is free software: you can redistribute it and/or modify
 * it under the terms of the Affero GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * Pixels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Affero GNU General Public License for more details.
 *
 * You should have received a copy of the Affero GNU General Public
 * License along with Pixels.  If not, see
 * <https://www.gnu.org/licenses/>.
 */
package io.pixelsdb.pixels.cache;

import org.junit.Before;
import org.junit.Test;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.Supplier;

public class BenchmarkCacheContentReader {
    // it can be generated by RadixTreeDumper
    String dumpedIndexFile = "dumpedCache.txt";
    // the cache content can be generated by FakeCacheGenerator
    String cacheContentFile = "/mnt/nvme1n1/pixels.cache";
    int threadNum = 1;

    @Before
    public void prepare ()
    {
        dumpedIndexFile = "dumpedCache.txt";
        cacheContentFile = "/mnt/nvme1n1/pixels.cache";
        threadNum = 8;
    }


    static class BenchmarkResult {
        double elapsed;
        double totalBytes;
        double totalIO;
        double iops;
        double bandwidthMb;
        double bandwidthMib;

        double latency;

        BenchmarkResult(double totalIO, double totalBytes, double elapsedInMili) {
            this.elapsed = elapsedInMili;
            this.totalBytes = totalBytes;
            this.totalIO = totalIO;
            this.iops = totalIO / (elapsed / 1e3);
            this.bandwidthMb = (totalBytes / 1000.0 / 1000.0) / (elapsed / 1e3);
            this.bandwidthMib = (totalBytes / 1024.0 / 1024.0) / (elapsed / 1e3);
            this.latency = 1.0 / this.iops * 1000;
        }

        @Override
        public String toString() {
            return String.format("elapsed=%fms(%fs), IOPS=%f, bandwidth=%fMB/s(%fMiB/s), latency=%fms, totalIO=%f, totalBytes=%fGiB",
                    elapsed, elapsed / 1e3, iops, bandwidthMb, bandwidthMib, latency, totalIO, totalBytes / 1024.0 / 1024.0 / 1024.0);
        }

    }

    private void benchmarkMultiThreadContentReader(Supplier<CacheContentReader> factory, int threadNum)
            throws InterruptedException, ExecutionException {
        ExecutorService[] executors = new ExecutorService[threadNum];
        List<Future<BenchmarkResult>> futures = new ArrayList<>();

        for (int i = 0; i < threadNum; ++i) {
            executors[i] = Executors.newSingleThreadExecutor();
            Future<BenchmarkResult> future = executors[i].submit(() -> {
                try {
                    List<PixelsCacheIdx> pixelsCacheIdxs = new ArrayList<>(4096);
                    BufferedReader br = new BufferedReader(new FileReader(dumpedIndexFile));
                    String line = br.readLine();
                    String idxString = "";
                    while (line != null) {
                        idxString = line.split(";")[2];

                        String[] idxTokens = idxString.split("-");
                        long offset = Long.parseLong(idxTokens[0]);
                        int length = Integer.parseInt(idxTokens[1]);
                        pixelsCacheIdxs.add(new PixelsCacheIdx(offset, length));
                        line = br.readLine();
                    }
//                        CacheContentReader reader = new DiskCacheContentReader("/mnt/nvme1n1/pixels.cache");
                    CacheContentReader reader = factory.get();

                    Collections.shuffle(pixelsCacheIdxs);
                    long totalBytes = 0;
                    int maxBytes = 0;
                    for (PixelsCacheIdx idx : pixelsCacheIdxs) {
                        totalBytes += idx.length;
                        if (idx.length > maxBytes) maxBytes = idx.length;
                    }
                    byte[] interal = new byte[maxBytes];
                    ByteBuffer buf = ByteBuffer.wrap(interal);
                    Random random = new Random();
                    long searchStart = System.nanoTime();
//                    for (int j = 0; j < pixelsCacheIdxs.size(); ++j) {
//                        int index = random.nextInt(pixelsCacheIdxs.size());
//                        reader.read(pixelsCacheIdxs.get(index), buf);
//                    }
                    for (PixelsCacheIdx idx : pixelsCacheIdxs) {
                        reader.read(idx, buf);
                    }
                    long searchEnd = System.nanoTime();
                    double elapsed = (double) (searchEnd - searchStart) / (double) 1e6;
                    BenchmarkResult result = new BenchmarkResult(pixelsCacheIdxs.size(), totalBytes, elapsed);
                    System.out.println(result);
//                        System.out.println("elapsed=" + elapsed + "ms" + " IOPS=" + pixelsCacheIdxs.size() / (elapsed / 1e3)
//                                + " bandwidth=" + (totalBytes / 1000.0 / 1000.0) / (elapsed / 1e3) + "Mb/s" + " readCount=" + pixelsCacheIdxs.size());
                    return result;

                } catch (IOException e) {
                    e.printStackTrace();
                }

                return null;
            });

            futures.add(future);

        }

        List<BenchmarkResult> results = new ArrayList<>(threadNum);
        for (int i = 0; i < threadNum; ++i) {
            results.add(futures.get(i).get());
        }
        double totalIOPS = 0.0;
        double totalBandwidthMB = 0.0;
        double totalBandwidthMiB = 0.0;

        double averageLatency = 0.0;
        for (BenchmarkResult res : results) {
            totalIOPS += res.iops;
            totalBandwidthMB += res.bandwidthMb;
            totalBandwidthMiB += res.bandwidthMib;
            averageLatency += res.latency;
        }
        averageLatency /= threadNum;
        System.out.println(String.format("threads=%d, totalIOPS=%f, bandwidth=%fMB(%fMiB), latency=%fms", threadNum, totalIOPS, totalBandwidthMB, totalBandwidthMiB, averageLatency));

    }

    @Test
    public void benchmarkMultiThreadDiskContentReader() throws IOException, InterruptedException, ExecutionException {
        benchmarkMultiThreadContentReader(() -> {
            try {
                return new DiskCacheContentReader(cacheContentFile);

            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }, threadNum);
    }

    @Test
    public void benchmarkMultiThreadMmapContentReader() throws IOException, InterruptedException, ExecutionException {
        benchmarkMultiThreadContentReader(() -> {
            try {
                MemoryMappedFile mmap = new MemoryMappedFile(cacheContentFile, 70L * 1024 * 1024 * 1024);
                return new MmapFileCacheContentReader(mmap);

            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        }, threadNum);
    }
}
