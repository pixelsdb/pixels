/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// File format definition of Pixels

syntax = "proto2";

package pixels.proto;

option java_package = "io.pixelsdb.pixels.core";
option java_outer_classname = "PixelsProto";

// Row Group: A logical horizontal partitioning of the data into rows. There is no physical
//            structure that is guaranteed for a row group. A row group consists of a column
//            chunk for each column in the dataset.
// Column Chunk: A chunk of the data for a particular column. These live in a particular row group and is guaranteed to
//               be contiguous in the file.
// Pixel: A column chunk is divided into several pixels. A pixel is conceptually an samllest indivisible unit in terms
//        of indexing. Each pixel contains a fixed num (like 10000) of values inside.

// The contents of the file tail that must be serialized.
message FileTail {
    optional Footer footer = 1;
    optional PostScript postscript = 2;
    optional uint32 footerLength = 3;
    optional uint32 postscriptLength = 4;
}

// PostScript
// version: pixels file version
// contentLength: file content length (everything except FileTail)
// number of rows: number of rows in the file
// compression: compression kind. currently USELESS
// compressionBlockSize: compression block size. currently USELESS
// pixelStride: the maximum number of rows in a pixel
// magic: "PIXELS"
message PostScript {
    optional uint32 version = 1;
    optional uint64 contentLength = 2;
    optional uint32 numberOfRows = 3;
    optional CompressionKind compression = 4;
    optional uint32 compressionBlockSize = 5;
    optional uint32 pixelStride = 6;
    optional string writerTimezone = 7;
    // Leave this last in the record
    optional string magic = 8000;
}

enum CompressionKind {
    NONE = 0;
    ZLIB = 1;
    SNAPPY = 2;
    LZO = 3;
    LZ4 = 4;
    ZSTD = 5;
}

// Footer
// types: file schema
// columnStats: file level column statistics
// rowGroupInfos: row group information
// rowGroupStats: row group statistics
message Footer {
    // schema
    repeated Type types = 1;
    // file level column statistics
    repeated ColumnStatistic columnStats = 2;
    repeated RowGroupInformation rowGroupInfos = 3;
    repeated RowGroupStatistic rowGroupStats = 4;
}

message Type {
    enum Kind {
        BOOLEAN = 0;
        BYTE = 1;
        SHORT = 2;
        INT = 3;
        LONG = 4;
        FLOAT = 5;
        DOUBLE = 6;
        STRING = 7;
        BINARY = 8;
        TIMESTAMP = 9;
        MAP = 11;
        STRUCT = 12;
        DATE = 15;
        VARCHAR = 16;
        CHAR = 17;
    }
    optional Kind kind = 1;
    optional string name = 2;
    repeated uint32 subtypes = 3 [packed=true];
    optional uint32 maximumLength = 4;
    optional uint32 precision = 5;
    optional uint32 scale = 6;
}

// Row group information.
// offset: row group start offset
// dataLength: row group serialized content length
// footerLength: serialized RowGroupFooter length
// numberOfRows: number of rows in this row group
message RowGroupInformation {
    optional uint64 footerOffset = 1;
    optional uint32 dataLength = 2;
    optional uint32 footerLength = 3;
    optional uint64 numberOfRows = 4;
}

// Row group statistic
// columnChunkStats: statistic for each column chunk.
// for example, min/max for col0 in this row group
// this can be used to filter row groups.
message RowGroupStatistic {
    repeated ColumnStatistic columnChunkStats = 1;
}

message IntegerStatistic  {
    optional sint64 minimum = 1;
    optional sint64 maximum = 2;
    optional sint64 sum = 3;
}

message DoubleStatistic {
    optional double minimum = 1;
    optional double maximum = 2;
    optional double sum = 3;
}

message StringStatistic {
    optional string minimum = 1;
    optional string maximum = 2;
    // sum will store the total length of all strings in a stripe
    optional sint64 sum = 3;
}

message BucketStatistic {
    repeated uint64 count = 1 [packed=true];
}

message TimestampStatistic {
    // min,max values saved as milliseconds since epoch
    optional sint64 minimum = 1;
    optional sint64 maximum = 2;
}

message BinaryStatistic {
    // sum will store the total binary blob length in a stripe
    optional sint64 sum = 1;
}

message ColumnStatistic {
    optional uint64 numberOfValues = 1;
    optional IntegerStatistic intStatistics = 2;
    optional DoubleStatistic doubleStatistics = 3;
    optional StringStatistic stringStatistics = 4;
    optional BucketStatistic bucketStatistics = 5;
    optional BinaryStatistic binaryStatistics = 6;
    optional TimestampStatistic timestampStatistics = 7;
    optional bool hasNull = 8;
}

// Pixel statistic
// statistic: statistic for this pixel
message PixelStatistic {
    optional ColumnStatistic statistic = 1;
}

// ColumnChunk index
// pixelPositions: starting offsets of each pixel in this column chunk
message ColumnChunkIndex {
//    optional ColumnStatistic columnStatistic = 1;
    optional uint64 chunkOffset = 1;
    optional uint64 chunkLength = 2;
    optional uint64 isNullOffset = 3;
    repeated uint64 pixelPositions = 4 [packed=true];
    repeated PixelStatistic pixelStatistics = 5;
}

message RowGroupIndex {
    repeated ColumnChunkIndex columnChunkIndexEntries = 1;
}

message RowGroupEncoding {
    repeated ColumnEncoding columnChunkEncodings = 1;
}

message RowGroupFooter {
    optional RowGroupIndex rowGroupIndexEntry = 1;
    optional RowGroupEncoding rowGroupEncoding = 2;
}

message ColumnEncoding {
    enum Kind {
        NONE = 0;
        RUNLENGTH = 1;
        DICTIONARY = 2;
    }

    required Kind kind = 1;
    optional uint32 dictionarySize = 2;
}